package vms

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// VirtualMachinesClient is the VM Client
type VirtualMachinesClient struct {
	BaseClient
}

// NewVirtualMachinesClient creates an instance of the VirtualMachinesClient client.
func NewVirtualMachinesClient() VirtualMachinesClient {
	return NewVirtualMachinesClientWithBaseURI(DefaultBaseURI)
}

// NewVirtualMachinesClientWithBaseURI creates an instance of the VirtualMachinesClient client using a custom endpoint.
// Use this when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewVirtualMachinesClientWithBaseURI(baseURI string) VirtualMachinesClient {
	return VirtualMachinesClient{NewWithBaseURI(baseURI)}
}

// AttachGPU VM  <br/>Attach a GPU device to VM
func (client VirtualMachinesClient) AttachGPU(ctx context.Context, ID int32, data *WritePCISerializer) (result GpuResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.AttachGPU")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: data,
			Constraints: []validation.Constraint{{Target: "data", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "data.SlotID", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("vms.VirtualMachinesClient", "AttachGPU", err.Error())
	}

	req, err := client.AttachGPUPreparer(ctx, ID, data)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "AttachGPU", nil, "Failure preparing request")
		return
	}

	resp, err := client.AttachGPUSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "AttachGPU", resp, "Failure sending request")
		return
	}

	result, err = client.AttachGPUResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "AttachGPU", resp, "Failure responding to request")
		return
	}

	return
}

// AttachGPUPreparer prepares the AttachGPU request.
func (client VirtualMachinesClient) AttachGPUPreparer(ctx context.Context, ID int32, data *WritePCISerializer) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/gpu", pathParameters))
	if data != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(data))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AttachGPUSender sends the AttachGPU request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) AttachGPUSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AttachGPUResponder handles the response to the AttachGPU request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) AttachGPUResponder(resp *http.Response) (result GpuResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CheckISO check (list) Windows 10 OS editions contained in an ISO
// example:
// { "isoPath" : "/share/Public/ISO/Windows10_Pro_Cht_x86_x64.iso" }
func (client VirtualMachinesClient) CheckISO(ctx context.Context, body Body) (result CheckIsoResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.CheckISO")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CheckISOPreparer(ctx, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "CheckISO", nil, "Failure preparing request")
		return
	}

	resp, err := client.CheckISOSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "CheckISO", resp, "Failure sending request")
		return
	}

	result, err = client.CheckISOResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "CheckISO", resp, "Failure responding to request")
		return
	}

	return
}

// CheckISOPreparer prepares the CheckISO request.
func (client VirtualMachinesClient) CheckISOPreparer(ctx context.Context, body Body) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/vms/check_iso"),
		autorest.WithJSON(body))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CheckISOSender sends the CheckISO request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) CheckISOSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CheckISOResponder handles the response to the CheckISO request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) CheckISOResponder(resp *http.Response) (result CheckIsoResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Clone VM  <br/>Clone VM
// example:
// {"name":"clone_vm","path":"/Public/clone_vm"}
func (client VirtualMachinesClient) Clone(ctx context.Context, ID int32, body string) (result CloneResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Clone")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ClonePreparer(ctx, ID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Clone", nil, "Failure preparing request")
		return
	}

	resp, err := client.CloneSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Clone", resp, "Failure sending request")
		return
	}

	result, err = client.CloneResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Clone", resp, "Failure responding to request")
		return
	}

	return
}

// ClonePreparer prepares the Clone request.
func (client VirtualMachinesClient) ClonePreparer(ctx context.Context, ID int32, body string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/clone", pathParameters),
		autorest.WithJSON(body))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CloneSender sends the Clone request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) CloneSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CloneResponder handles the response to the Clone request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) CloneResponder(resp *http.Response) (result CloneResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Create create a new VM
func (client VirtualMachinesClient) Create(ctx context.Context, data *WriteVMSerializer) (result CreateResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Create")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: data,
			Constraints: []validation.Constraint{{Target: "data", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "data.Memory", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "data.Name", Name: validation.Null, Rule: true,
						Chain: []validation.Constraint{{Target: "data.Name", Name: validation.MaxLength, Rule: 32, Chain: nil}}},
				}}}}}); err != nil {
		return result, validation.NewError("vms.VirtualMachinesClient", "Create", err.Error())
	}

	req, err := client.CreatePreparer(ctx, data)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Create", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Create", resp, "Failure sending request")
		return
	}

	result, err = client.CreateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Create", resp, "Failure responding to request")
		return
	}

	return
}

// CreatePreparer prepares the Create request.
func (client VirtualMachinesClient) CreatePreparer(ctx context.Context, data *WriteVMSerializer) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/vms"))
	if data != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(data))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateSender sends the Create request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) CreateSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateResponder handles the response to the Create request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) CreateResponder(resp *http.Response) (result CreateResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateAutoInstallDevice VM  <br/>Create Auto Install USB Device
func (client VirtualMachinesClient) CreateAutoInstallDevice(ctx context.Context, ID int32, body string) (result CreateAutoInstallDeviceResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.CreateAutoInstallDevice")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CreateAutoInstallDevicePreparer(ctx, ID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "CreateAutoInstallDevice", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateAutoInstallDeviceSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "CreateAutoInstallDevice", resp, "Failure sending request")
		return
	}

	result, err = client.CreateAutoInstallDeviceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "CreateAutoInstallDevice", resp, "Failure responding to request")
		return
	}

	return
}

// CreateAutoInstallDevicePreparer prepares the CreateAutoInstallDevice request.
func (client VirtualMachinesClient) CreateAutoInstallDevicePreparer(ctx context.Context, ID int32, body string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/create_auto_install_device", pathParameters),
		autorest.WithJSON(body))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateAutoInstallDeviceSender sends the CreateAutoInstallDevice request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) CreateAutoInstallDeviceSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateAutoInstallDeviceResponder handles the response to the CreateAutoInstallDevice request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) CreateAutoInstallDeviceResponder(resp *http.Response) (result CreateAutoInstallDeviceResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Destroy VM  <br/>Delete a VM
func (client VirtualMachinesClient) Destroy(ctx context.Context, ID int32, data string) (result DestroyResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Destroy")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DestroyPreparer(ctx, ID, data)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Destroy", nil, "Failure preparing request")
		return
	}

	resp, err := client.DestroySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Destroy", resp, "Failure sending request")
		return
	}

	result, err = client.DestroyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Destroy", resp, "Failure responding to request")
		return
	}

	return
}

// DestroyPreparer prepares the Destroy request.
func (client VirtualMachinesClient) DestroyPreparer(ctx context.Context, ID int32, data string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}", pathParameters))
	if len(data) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(data))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DestroySender sends the Destroy request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) DestroySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DestroyResponder handles the response to the Destroy request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) DestroyResponder(resp *http.Response) (result DestroyResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DestroyGPU detach a GPU device from VM
func (client VirtualMachinesClient) DestroyGPU(ctx context.Context, vmid int32, slotKey string) (result GPUDestroyResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.DestroyGPU")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DestroyGPUPreparer(ctx, vmid, slotKey)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "DestroyGPU", nil, "Failure preparing request")
		return
	}

	resp, err := client.DestroyGPUSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "DestroyGPU", resp, "Failure sending request")
		return
	}

	result, err = client.DestroyGPUResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "DestroyGPU", resp, "Failure responding to request")
		return
	}

	return
}

// DestroyGPUPreparer prepares the DestroyGPU request.
func (client VirtualMachinesClient) DestroyGPUPreparer(ctx context.Context, vmid int32, slotKey string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"slot_key": autorest.Encode("path", slotKey),
		"vm_id":    autorest.Encode("path", vmid),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{vm_id}/gpu/{slot_key}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DestroyGPUSender sends the DestroyGPU request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) DestroyGPUSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DestroyGPUResponder handles the response to the DestroyGPU request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) DestroyGPUResponder(resp *http.Response) (result GPUDestroyResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Export VM  <br/>Export VM
// example:
// {"exportFileName":"export_vm",
// "exportType":"local",
// "exportPath":"/Public/VMs",
// "includeISO":false,
// "exportFormat":"qvm",
// "compressImage":false}
// option: remoteNAS
func (client VirtualMachinesClient) Export(ctx context.Context, ID int32, body string) (result ExportResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Export")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ExportPreparer(ctx, ID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Export", nil, "Failure preparing request")
		return
	}

	resp, err := client.ExportSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Export", resp, "Failure sending request")
		return
	}

	result, err = client.ExportResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Export", resp, "Failure responding to request")
		return
	}

	return
}

// ExportPreparer prepares the Export request.
func (client VirtualMachinesClient) ExportPreparer(ctx context.Context, ID int32, body string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/export", pathParameters),
		autorest.WithJSON(body))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ExportSender sends the Export request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) ExportSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ExportResponder handles the response to the Export request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) ExportResponder(resp *http.Response) (result ExportResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ForceShutdown VM  <br/>Force Shutdown VM
func (client VirtualMachinesClient) ForceShutdown(ctx context.Context, ID int32) (result ForceshutdownResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.ForceShutdown")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ForceShutdownPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "ForceShutdown", nil, "Failure preparing request")
		return
	}

	resp, err := client.ForceShutdownSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "ForceShutdown", resp, "Failure sending request")
		return
	}

	result, err = client.ForceShutdownResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "ForceShutdown", resp, "Failure responding to request")
		return
	}

	return
}

// ForceShutdownPreparer prepares the ForceShutdown request.
func (client VirtualMachinesClient) ForceShutdownPreparer(ctx context.Context, ID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/forceshutdown", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ForceShutdownSender sends the ForceShutdown request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) ForceShutdownSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ForceShutdownResponder handles the response to the ForceShutdown request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) ForceShutdownResponder(resp *http.Response) (result ForceshutdownResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetIPs VM  <br/>Get VM IPs by qemu-img agent
func (client VirtualMachinesClient) GetIPs(ctx context.Context, ID int32) (result IpsResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.GetIPs")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetIPsPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "GetIPs", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetIPsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "GetIPs", resp, "Failure sending request")
		return
	}

	result, err = client.GetIPsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "GetIPs", resp, "Failure responding to request")
		return
	}

	return
}

// GetIPsPreparer prepares the GetIPs request.
func (client VirtualMachinesClient) GetIPsPreparer(ctx context.Context, ID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/ips", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetIPsSender sends the GetIPs request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) GetIPsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetIPsResponder handles the response to the GetIPs request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) GetIPsResponder(resp *http.Response) (result IpsResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// List list all VMs
// Parameters:
// detail - only evaluated when from_qvscli == true
// pci - only evaluated when from_qvscli == true
func (client VirtualMachinesClient) List(ctx context.Context, syncParameter bool, fromQvscli *bool, detail *bool, pci *bool) (result ListResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.List")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListPreparer(ctx, syncParameter, fromQvscli, detail, pci)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "List", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "List", resp, "Failure sending request")
		return
	}

	result, err = client.ListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "List", resp, "Failure responding to request")
		return
	}

	return
}

// ListPreparer prepares the List request.
func (client VirtualMachinesClient) ListPreparer(ctx context.Context, syncParameter bool, fromQvscli *bool, detail *bool, pci *bool) (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"sync": autorest.Encode("query", syncParameter),
	}
	if fromQvscli != nil {
		queryParameters["from_qvscli"] = autorest.Encode("query", *fromQvscli)
	}
	if detail != nil {
		queryParameters["detail"] = autorest.Encode("query", *detail)
	}
	if pci != nil {
		queryParameters["pci"] = autorest.Encode("query", *pci)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/vms"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSender sends the List request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) ListSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListResponder handles the response to the List request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) ListResponder(resp *http.Response) (result ListResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListStates list all VMs states
func (client VirtualMachinesClient) ListStates(ctx context.Context) (result StatesResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.ListStates")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListStatesPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "ListStates", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListStatesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "ListStates", resp, "Failure sending request")
		return
	}

	result, err = client.ListStatesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "ListStates", resp, "Failure responding to request")
		return
	}

	return
}

// ListStatesPreparer prepares the ListStates request.
func (client VirtualMachinesClient) ListStatesPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/vms/states"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListStatesSender sends the ListStates request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) ListStatesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListStatesResponder handles the response to the ListStates request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) ListStatesResponder(resp *http.Response) (result StatesResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PartialUpdate VM  <br/>Modify the VM setting
func (client VirtualMachinesClient) PartialUpdate(ctx context.Context, ID int32, body *WriteVMSerializer) (result PartialUpdateResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.PartialUpdate")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PartialUpdatePreparer(ctx, ID, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "PartialUpdate", nil, "Failure preparing request")
		return
	}

	resp, err := client.PartialUpdateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "PartialUpdate", resp, "Failure sending request")
		return
	}

	result, err = client.PartialUpdateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "PartialUpdate", resp, "Failure responding to request")
		return
	}

	return
}

// PartialUpdatePreparer prepares the PartialUpdate request.
func (client VirtualMachinesClient) PartialUpdatePreparer(ctx context.Context, ID int32, body *WriteVMSerializer) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}", pathParameters))
	if body != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(body))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PartialUpdateSender sends the PartialUpdate request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) PartialUpdateSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// PartialUpdateResponder handles the response to the PartialUpdate request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) PartialUpdateResponder(resp *http.Response) (result PartialUpdateResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Restart VM  <br/>Restart VM
func (client VirtualMachinesClient) Restart(ctx context.Context, ID int32) (result ResetResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Restart")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.RestartPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Restart", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Restart", resp, "Failure sending request")
		return
	}

	result, err = client.RestartResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Restart", resp, "Failure responding to request")
		return
	}

	return
}

// RestartPreparer prepares the Restart request.
func (client VirtualMachinesClient) RestartPreparer(ctx context.Context, ID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/reset", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestartSender sends the Restart request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) RestartSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RestartResponder handles the response to the Restart request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) RestartResponder(resp *http.Response) (result ResetResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Resume VM  <br/>Resume VM
// example:
// flag for sync time
// {"sync_time" : false}
// Parameters:
// data - {"sync_time":false}
func (client VirtualMachinesClient) Resume(ctx context.Context, ID int32, data *Data) (result ResumeResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Resume")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ResumePreparer(ctx, ID, data)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Resume", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResumeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Resume", resp, "Failure sending request")
		return
	}

	result, err = client.ResumeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Resume", resp, "Failure responding to request")
		return
	}

	return
}

// ResumePreparer prepares the Resume request.
func (client VirtualMachinesClient) ResumePreparer(ctx context.Context, ID int32, data *Data) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/resume", pathParameters))
	if data != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(data))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResumeSender sends the Resume request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) ResumeSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResumeResponder handles the response to the Resume request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) ResumeResponder(resp *http.Response) (result ResumeResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Retrieve VM  <br/>Find VM by id
func (client VirtualMachinesClient) Retrieve(ctx context.Context, ID int32) (result RetrieveResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Retrieve")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.RetrievePreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Retrieve", nil, "Failure preparing request")
		return
	}

	resp, err := client.RetrieveSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Retrieve", resp, "Failure sending request")
		return
	}

	result, err = client.RetrieveResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Retrieve", resp, "Failure responding to request")
		return
	}

	return
}

// RetrievePreparer prepares the Retrieve request.
func (client VirtualMachinesClient) RetrievePreparer(ctx context.Context, ID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RetrieveSender sends the Retrieve request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) RetrieveSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RetrieveResponder handles the response to the Retrieve request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) RetrieveResponder(resp *http.Response) (result RetrieveResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Shutdown VM  <br/>Shutdown VM
func (client VirtualMachinesClient) Shutdown(ctx context.Context, ID int32) (result ShutdownResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Shutdown")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ShutdownPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Shutdown", nil, "Failure preparing request")
		return
	}

	resp, err := client.ShutdownSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Shutdown", resp, "Failure sending request")
		return
	}

	result, err = client.ShutdownResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Shutdown", resp, "Failure responding to request")
		return
	}

	return
}

// ShutdownPreparer prepares the Shutdown request.
func (client VirtualMachinesClient) ShutdownPreparer(ctx context.Context, ID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/shutdown", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ShutdownSender sends the Shutdown request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) ShutdownSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ShutdownResponder handles the response to the Shutdown request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) ShutdownResponder(resp *http.Response) (result ShutdownResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Start VM  <br/>Start VM
func (client VirtualMachinesClient) Start(ctx context.Context, ID int32) (result StartResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Start")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.StartPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Start", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Start", resp, "Failure sending request")
		return
	}

	result, err = client.StartResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Start", resp, "Failure responding to request")
		return
	}

	return
}

// StartPreparer prepares the Start request.
func (client VirtualMachinesClient) StartPreparer(ctx context.Context, ID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/start", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartSender sends the Start request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) StartSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartResponder handles the response to the Start request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) StartResponder(resp *http.Response) (result StartResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// StoppingProgress VM  <br/>List all VMs states and Stopping progress
func (client VirtualMachinesClient) StoppingProgress(ctx context.Context) (result StoppingProgressResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.StoppingProgress")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.StoppingProgressPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "StoppingProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.StoppingProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "StoppingProgress", resp, "Failure sending request")
		return
	}

	result, err = client.StoppingProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "StoppingProgress", resp, "Failure responding to request")
		return
	}

	return
}

// StoppingProgressPreparer prepares the StoppingProgress request.
func (client VirtualMachinesClient) StoppingProgressPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/vms/stopping_progress"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StoppingProgressSender sends the StoppingProgress request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) StoppingProgressSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StoppingProgressResponder handles the response to the StoppingProgress request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) StoppingProgressResponder(resp *http.Response) (result StoppingProgressResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Suspend VM  <br/>Suspend VM
func (client VirtualMachinesClient) Suspend(ctx context.Context, ID int32) (result SuspendResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Suspend")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.SuspendPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Suspend", nil, "Failure preparing request")
		return
	}

	resp, err := client.SuspendSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Suspend", resp, "Failure sending request")
		return
	}

	result, err = client.SuspendResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Suspend", resp, "Failure responding to request")
		return
	}

	return
}

// SuspendPreparer prepares the Suspend request.
func (client VirtualMachinesClient) SuspendPreparer(ctx context.Context, ID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/suspend", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SuspendSender sends the Suspend request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) SuspendSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SuspendResponder handles the response to the Suspend request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) SuspendResponder(resp *http.Response) (result SuspendResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Sync VM  <br/>Sync VM settings with libvirt by vm id
func (client VirtualMachinesClient) Sync(ctx context.Context, ID int32) (result SyncResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesClient.Sync")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.SyncPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Sync", nil, "Failure preparing request")
		return
	}

	resp, err := client.SyncSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Sync", resp, "Failure sending request")
		return
	}

	result, err = client.SyncResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "vms.VirtualMachinesClient", "Sync", resp, "Failure responding to request")
		return
	}

	return
}

// SyncPreparer prepares the Sync request.
func (client VirtualMachinesClient) SyncPreparer(ctx context.Context, ID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/vms/{id}/sync", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SyncSender sends the Sync request. The method will close the
// http.Response Body if it receives an error.
func (client VirtualMachinesClient) SyncSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SyncResponder handles the response to the Sync request. The method always
// closes the http.Response Body.
func (client VirtualMachinesClient) SyncResponder(resp *http.Response) (result SyncResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
